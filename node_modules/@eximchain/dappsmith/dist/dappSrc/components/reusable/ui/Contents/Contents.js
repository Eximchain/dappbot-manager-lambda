"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __importStar(require("react"));
var classnames_1 = __importDefault(require("classnames"));
var StyledContents_1 = __importDefault(require("./StyledContents"));
var Caret_1 = __importDefault(require("./../Caret"));
/* Needed until this Flow issue is fixed: https://github.com/facebook/flow/issues/380 */
/* eslint quote-props: 0 */
var SPACES_INDEX_MAP = {
    "0": "up",
    "1": "right",
    "2": "down",
    "3": "left"
};
var DIR_INDEX_MAP = {
    up: 0,
    right: 1,
    down: 2,
    left: 3
};
var MARGIN = 24;
exports.CARET_HEIGHT = 24;
var CARET_OFFSET_FROM_SIDE = 24;
exports.BORDER_RADIUS = 8;
/**
 * Determines the main direction the flyout opens
 */
function getMainDir(flyoutSize, idealDirection, triggerRect, windowSize) {
    // Calculates the available space if we were to place the flyout in the 4 main directions
    // to determine which 'quadrant' to position the flyout inside of
    var up = triggerRect.top - flyoutSize.height - exports.CARET_HEIGHT;
    var right = windowSize.width - flyoutSize.width - exports.CARET_HEIGHT - triggerRect.right;
    var down = windowSize.height - flyoutSize.height - exports.CARET_HEIGHT - triggerRect.bottom;
    var left = triggerRect.left - flyoutSize.width - exports.CARET_HEIGHT;
    // overrides available space when the trigger is close to the edge of the screen
    // trigger is too close to top/bottom of screen for left & right flyouts
    if (triggerRect.top < exports.BORDER_RADIUS ||
        windowSize.height - triggerRect.bottom < exports.BORDER_RADIUS) {
        left = 0;
        right = 0;
    }
    // trigger is too close to the left/right of screen for up & down flyouts
    if (triggerRect.left < exports.BORDER_RADIUS ||
        windowSize.width - triggerRect.right < exports.BORDER_RADIUS) {
        up = 0;
        down = 0;
    }
    var spaces = [up, right, down, left];
    // Identify best direction of available spaces
    var max = Math.max.apply(Math, __spread(spaces));
    // Chose the main direction for the flyout based on available spaces & user preference
    var mainDir;
    if (idealDirection && spaces[DIR_INDEX_MAP[idealDirection]] > 0) {
        // user pref
        mainDir = idealDirection;
    }
    else {
        // If no direction pref, chose the direction in which there is the most space available
        mainDir = SPACES_INDEX_MAP[spaces.indexOf(max)];
    }
    return mainDir;
}
exports.getMainDir = getMainDir;
/**
 * Determines the sub direction of how the flyout is positioned within the main dir
 */
function getSubDir(flyoutSize, mainDir, triggerRect, windowSize) {
    // Now that we have the main direction, chose from 3 caret placements for that direction
    var offset;
    var triggerMid;
    var windowSpaceAvailable;
    if (mainDir === "right" || mainDir === "left") {
        offset = flyoutSize.height / 2;
        triggerMid = triggerRect.top + (triggerRect.bottom - triggerRect.top) / 2;
        windowSpaceAvailable = windowSize.height;
    }
    else {
        // (mainDir === 'up' || mainDir === 'down')
        offset = flyoutSize.width / 2;
        triggerMid = triggerRect.left + (triggerRect.right - triggerRect.left) / 2;
        windowSpaceAvailable = windowSize.width;
    }
    var aboveOrLeft = triggerMid - offset - MARGIN;
    var belowOrRight = windowSpaceAvailable - triggerMid - offset - MARGIN;
    var subDir;
    if (aboveOrLeft > 0 && belowOrRight > 0) {
        // caret should go in middle b/c it can
        subDir = "middle";
    }
    else if (belowOrRight > 0) {
        // caret should go at top for left/right and left for up/down
        subDir = mainDir === "left" || mainDir === "right" ? "up" : "left";
    }
    else {
        // caret should go at bottom for left/right and right for up/down
        subDir = mainDir === "left" || mainDir === "right" ? "down" : "right";
    }
    return subDir;
}
exports.getSubDir = getSubDir;
/**
 * Calculates the amount the flyout & caret need to shift over to align with designs
 */
function calcEdgeShifts(subDir, triggerRect, windowSize) {
    // Target values for flyout and caret shifts
    var flyoutVerticalShift = CARET_OFFSET_FROM_SIDE - (triggerRect.height - exports.CARET_HEIGHT) / 2;
    var flyoutHorizontalShift = CARET_OFFSET_FROM_SIDE - (triggerRect.width - exports.CARET_HEIGHT) / 2;
    var caretVerticalShift = exports.CARET_HEIGHT;
    var caretHorizontalShift = exports.CARET_HEIGHT;
    // Covers edge case where trigger is in a corner and we need to adjust the offset of the caret
    // to something smaller than normal in order
    var isCloseVertically = triggerRect.top - flyoutVerticalShift < 0 ||
        triggerRect.bottom + flyoutVerticalShift > windowSize.height;
    var isCloseHorizontally = triggerRect.left - flyoutHorizontalShift < 0 ||
        triggerRect.right + flyoutHorizontalShift > windowSize.width;
    if (isCloseVertically) {
        flyoutVerticalShift =
            exports.BORDER_RADIUS - (triggerRect.height - exports.CARET_HEIGHT) / 2;
        caretVerticalShift = exports.BORDER_RADIUS;
    }
    if (isCloseHorizontally) {
        flyoutHorizontalShift =
            exports.BORDER_RADIUS - (triggerRect.width - exports.CARET_HEIGHT) / 2;
        caretHorizontalShift = exports.BORDER_RADIUS;
    }
    return {
        flyout: {
            x: flyoutHorizontalShift,
            y: flyoutVerticalShift
        },
        caret: {
            x: caretHorizontalShift,
            y: caretVerticalShift
        }
    };
}
exports.calcEdgeShifts = calcEdgeShifts;
/**
 * Calculates flyout and caret offsets for styling
 */
function adjustOffsets(base, edgeShift, flyoutSize, mainDir, subDir, triggerRect) {
    var flyoutLeft = base.left;
    var flyoutTop = triggerRect.height - flyoutSize.height / 2;
    var caretTop = mainDir === "down" ? -exports.CARET_HEIGHT : undefined;
    var caretRight = mainDir === "left" ? -exports.CARET_HEIGHT : undefined;
    var caretBottom = undefined;
    var caretLeft = mainDir === "right" ? -exports.CARET_HEIGHT : undefined;
    if (subDir === "up") {
        flyoutTop = base.top - edgeShift.flyout.y;
        caretTop = edgeShift.caret.y;
    }
    else if (subDir === "down") {
        flyoutTop =
            base.top - flyoutSize.height + triggerRect.height + edgeShift.flyout.y;
        caretBottom = edgeShift.caret.y;
    }
    else if (subDir === "left") {
        flyoutLeft = base.left - edgeShift.flyout.x;
        caretLeft = edgeShift.caret.x;
    }
    else if (subDir === "right") {
        flyoutLeft =
            base.left - flyoutSize.width + triggerRect.width + edgeShift.flyout.x;
        caretRight = edgeShift.caret.x;
    }
    else if (subDir === "middle") {
        if (mainDir === "left" || mainDir === "right") {
            var triggerMid = flyoutTop + triggerRect.height / 2;
            flyoutTop = triggerMid - flyoutSize.height / 2;
            caretTop = (flyoutSize.height - exports.CARET_HEIGHT) / 2;
        }
        if (mainDir === "up" || mainDir === "down") {
            var triggerMid = flyoutLeft + triggerRect.width / 2;
            flyoutLeft = triggerMid - flyoutSize.width / 2;
            caretLeft = (flyoutSize.width - exports.CARET_HEIGHT) / 2;
        }
    }
    return {
        flyoutOffset: {
            top: flyoutTop,
            left: flyoutLeft
        },
        caretOffset: {
            top: caretTop,
            right: caretRight,
            bottom: caretBottom,
            left: caretLeft
        }
    };
}
exports.adjustOffsets = adjustOffsets;
/* Calculates baseline top and left offset for flyout */
function baseOffsets(relativeOffset, flyoutSize, mainDir, triggerRect, windowSize) {
    var HALF_CARET = exports.CARET_HEIGHT / 2;
    // TOP OFFSET
    var top;
    if (mainDir === "down") {
        top = windowSize.scrollY + triggerRect.bottom + HALF_CARET;
    }
    else if (mainDir === "up") {
        top =
            windowSize.scrollY + (triggerRect.top - flyoutSize.height - HALF_CARET);
    }
    else {
        // left and right
        top = windowSize.scrollY + triggerRect.top;
    }
    // LEFT OFFSET
    var left;
    if (mainDir === "left") {
        left =
            windowSize.scrollX + (triggerRect.left - flyoutSize.width - HALF_CARET);
    }
    else if (mainDir === "right") {
        left = windowSize.scrollX + triggerRect.right + HALF_CARET;
    }
    else {
        // down and up
        left = windowSize.scrollX + triggerRect.left;
    }
    // Adjusts for the relative parent container
    top -= relativeOffset.y;
    left -= relativeOffset.x;
    return { top: top, left: left };
}
exports.baseOffsets = baseOffsets;
var Contents = /** @class */ (function (_super) {
    __extends(Contents, _super);
    function Contents() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = {
            flyoutOffset: {
                top: undefined,
                right: undefined,
                bottom: undefined,
                left: undefined
            },
            caretOffset: {
                top: undefined,
                right: undefined,
                bottom: undefined,
                left: undefined
            },
            mainDir: undefined
        };
        /**
         * Determines the main direciton, sub direction, and corresponding offsets needed
         * to correctly position the offset
         */
        _this.setFlyoutPosition = function (props) {
            var relativeOffset = props.relativeOffset, idealDirection = props.idealDirection, positionRelativeToAnchor = props.positionRelativeToAnchor, triggerRect = props.triggerRect, width = props.width;
            // Scroll not needed for relative elements
            // We can't use window.scrollX / window.scrollY since it's not supported by IE11
            var scrollX = positionRelativeToAnchor
                ? 0
                : window.pageXOffset ||
                    (document.documentElement && document.documentElement.scrollLeft) ||
                    0;
            var scrollY = positionRelativeToAnchor
                ? 0
                : window.pageYOffset ||
                    (document.documentElement && document.documentElement.scrollTop) ||
                    0;
            var windowSize = {
                height: window.innerHeight,
                width: window.innerWidth,
                scrollX: scrollX,
                scrollY: scrollY
            };
            var flyoutSize = {
                height: _this.flyout && _this.flyout.current
                    ? _this.flyout.current.clientHeight
                    : 0,
                width: width
            };
            // First choose one of 4 main direction
            var mainDir = getMainDir(flyoutSize, idealDirection, triggerRect, windowSize);
            // Now that we have the main direction, chose from 3 caret placements for that direction
            var subDir = getSubDir(flyoutSize, mainDir, triggerRect, windowSize);
            // Gets the base offset that positions the flyout based on the main direction only
            var base = baseOffsets(relativeOffset, flyoutSize, mainDir, triggerRect, windowSize);
            // Gets the edge shifts for the flyout
            var edgeShifts = calcEdgeShifts(subDir, triggerRect, windowSize);
            // Adjusts for the subdirection of the caret
            var _a = adjustOffsets(base, edgeShifts, flyoutSize, mainDir, subDir, triggerRect), flyoutOffset = _a.flyoutOffset, caretOffset = _a.caretOffset;
            _this.setState({
                caretOffset: caretOffset,
                flyoutOffset: flyoutOffset,
                mainDir: mainDir
            });
        };
        _this.flyout = React.createRef();
        return _this;
    }
    Contents.prototype.componentDidMount = function () {
        var _this = this;
        this.setFlyoutPosition(this.props);
        setTimeout(function () {
            if (_this.props.shouldFocus && _this.flyout && _this.flyout.current) {
                _this.flyout.current.focus();
            }
        });
        window.addEventListener("resize", this.props.onResize);
        window.addEventListener("keydown", this.props.onKeyDown);
    };
    Contents.prototype.componentWillReceiveProps = function (nextProps) {
        this.setFlyoutPosition(nextProps);
    };
    Contents.prototype.componentWillUnmount = function () {
        window.removeEventListener("resize", this.props.onResize);
        window.removeEventListener("keydown", this.props.onKeyDown);
    };
    Contents.prototype.render = function () {
        var _a = this.props, bgColor = _a.bgColor, children = _a.children, width = _a.width;
        // Needed to prevent UI thrashing
        var visibility = this.state.mainDir == undefined ? "hidden" : "visible";
        var background = bgColor + "Bg";
        var stroke = bgColor === "white" ? "#efefef" : undefined;
        var borderColor = bgColor === "white" ? "lightGray" : bgColor;
        return (React.createElement(StyledContents_1.default, { className: "container", style: __assign({ stroke: stroke, visibility: visibility }, this.state.flyoutOffset) },
            React.createElement("div", { className: classnames_1.default(background, borderColor, "dimensions", "contents", "flyout"), ref: this.flyout, tabIndex: -1 },
                React.createElement("div", { className: classnames_1.default("dimensions", "innerContents"), style: { width: width } }, children),
                React.createElement("div", { className: classnames_1.default(bgColor, "caret"), style: __assign({}, this.state.caretOffset) },
                    React.createElement(Caret_1.default, { direction: this.state.mainDir })))));
    };
    return Contents;
}(React.Component));
exports.default = Contents;
//# sourceMappingURL=Contents.js.map