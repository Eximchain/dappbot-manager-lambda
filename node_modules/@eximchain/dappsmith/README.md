# DappSmith
An easy way to convert a smart contract's ABI into a full-fledged static web client.  

> Principles: Readability beats conciseness, rely on conventions, ready for customization.

This client:

1. Uses Guardian for auth & signing so end-users have automatic accounts tied to Okta login
2. Uses abi2gui to create functional interface for building the transaction payload
3. Uses a transaction executor (a la Infura) to submit without a local node

It explicitly does not recreate every feature from a wallet.  The generated client is a streamlined solution for using the given Contract with Guardian, nothing else.  The GUIs look a little something like this:

![Screenshot of a generated dapp for CryptoKitties](/crypto-kitty-screenshot.png)

## Usage
DappSmith can be used both as a CLI or as a module.  

### CLI 
Install globally and call it like so:

```
npm i -g @eximchain/dappsmith

dappsmith --help

dappsmith <contract_name> <path/to/contract> <deployed_addr> <web3URL> [options]
```

You can provide `--build` and `--start` if you would like the dapp to automatically do either of those things after generation.

### Module
Install it to your project, import the generate function, and call it with the appropriate input object:

``` 
npm i @eximchain/dappsmith

...

import DappSmith from '@eximchain/dappsmith';

DappSmith.generate({
    name: 'low-case-contract-name',
    abi: [MethodABI array],
    contract_addr: '0xDeployedAddress',
    web3URL: 'https://web3-http-provider-url.com'
}, { build: true, start: true });

// OR

const DappSmith = require('@eximchain/dappsmith');

DappSmith.generate(...);

// OR

const { generate } = require('@eximchain/dappsmith');

generate(...);
```

The generate method runs synchronously.

## File Structure
The baseline client is the `create-react-app` boilerplate, which we then expand with some standard components and a Redux store for managing transaction param data.  Below layout describes our additions to the contents of `src`:
```
-| App.tsx
-| Contract.json
-| /components
---| /layout
-----| Header.tsx
-----| TxMainPane.tsx
-----| TxSidePane.tsx
-----| TxModal.tsx
-----| TxListItem.tsx
---| /reusable
-----| ReadTx.tsx
-----| WriteTx.tsx
-----| /fields
-------| AddressField.tsx
-------| BooleanField.tsx
-------| NumberField.tsx
-------| StringField.tsx
---| /txFxns
-----| /reads
-------| [ReadFxnName].tsx
-------| ...
-----| /writes
-------| [WriteFxnName].tsx
-------| ...
-| /fonts
---| DinRoundPro...
---| ...
-| /state
---| /txDucks
-----| /[FxnName]
-------| actions.ts
-------| index.ts
-------| reducers.ts
-------| selectors.ts
-------| types.ts
-----| ...
---| /reusable
-------| actions.ts
-------| index.ts
-------| reducers.ts
-------| selectors.ts
-------| types.ts
-------| util.ts
---| Contract.ts
---| index.ts
---| store.ts
```

**Comments:**
- The `TxModal.tsx` component is included so that each contract function can be imported independently of the rest of the app.  The app would load functions into the MainPane, whereas directly importing one function from the app would load it into a Modal for arbitrary use by the consumer.
- The top-level `types` directory contains types which are shared between Redux files and React components, such as function arguments and primitive Ethereum types.
- `Guardian` service will handle the actual API calls for authentication and transaction submission, it will use a reusable "get current data" selector to fetch the current data payload of the currently-selected function.
- May end up wanting other services or a utils folder -- will see as development progresses.

### Redux Implementation
Redux is exclusively used for managing the method parameter values, as well as calculating the resulting `data` field.  This allows for persistent form state even as we switch between forms, and works out to a very clean API for plugging `data` into Guardian.  Refer to our separate [`abi2reducks`](https://github.com/Eximchain/abi2reducks) library for more details.

As of now, we do not need to store any authentication or address data in Redux.  The from address is inferred by Guardian, the to address is fixed to the contract.  However, if we want to display the user's address elsewhere in the application, it may become worthwhile to plug this value into Redux.

## Future Work
- Viewing transaction receipts and parsing the events that were triggered.
- [Maybe] Build out a Metamask hookup so these Dapps work with current state-of-the-art.