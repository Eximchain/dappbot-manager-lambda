# DappSmith
An easy way to convert a smart contract's ABI into a full-fledged static web client.  

> Principles: Readability beats conciseness, rely on conventions, ready for customization.

This client:

1. Uses Guardian for auth & signing so end-users have automatic accounts tied to Okta login
2. Uses abi2gui to create functional interface for building the transaction payload
3. Uses a transaction executor (a la Infura) to submit without a local node

## High-level GUI Ideas
- Use the `create-react-app` boilerplate: 
    - It's broadly accepted and provides easy upgrade paths over the long term.  
    - Static build capabilities are built-in, making deployment painless.
    - Can use the nodejs `shell` package to call it programatically
- Build all data into a Redux store:
    - Redux has the largest ecosystem of all f.lux implementations, easy to extend with good packages.
    - Enduser can restart with a new GUI and already have all the data handling ready to go.
    - Verbosity makes it very clear about what the data is and how it is modified.
- Component Library: Eximchain components vs Semantic-UI
- People already have a wallet, these DApps don't need to recreate all that.  Keep it streamlined to just using the contract, either with Guardian or your own key.

### Core Layout
- Side and main panel of tiles where each one is a function -- open one is in the main view.  Think roughly like Telegram
    - Was thinking button/div which when clicked brings up a modal for that function, this way we can layer into any other page or part of another process.
- All of the writes, then all of the reads
    - lgtm
- Search bar to filter functions by name
    - lgtm
- Upper right panel showing the username, associated address, and its balance -- try to style this almost like the identity badges on regular website accounts.  Make this feel seamless, just like a regular website.
    - have top and side navs in the exim component library
- Clicking on any of the functions turns it into a full-width box holding a form with any required inputs.
    - lgtm

### File Structure
The baseline client will be the `create-react-app` boilerplate, which autogenerates our root `/src` directory and an `App.tsx` file.  Below layout describes the contents of `src`:
```
-| [ContractName]ABI.json
-| /components
---| /layout
-----| Header.tsx
-----| TxMainPane.tsx
-----| TxSidePane.tsx
-----| TxModal.tsx
-----| TxListItem.tsx
---| /reusable
-----| ReadTx.tsx
-----| WriteTx.tsx
-----| /fields
-------| AddressField.tsx
-------| BooleanField.tsx
-------| NumberField.tsx
-------| StringField.tsx
---| /txFxns
-----| /reads
-------| [ReadFxnName].tsx
-------| ...
-----| /writes
-------| [WriteFxnName].tsx
-------| ...
-| /redux
---| /TxDucks
-----| /[FxnName]
-------| actions.ts
-------| index.ts
-------| reducers.ts
-------| selectors.ts
-------| tests.ts
-------| types.ts
-----| ...
---| /UIDuck
-----| ...
---| reusable.ts
---| index.ts
-| /services
---| guardian.ts
-| /types
---| [FxnName].ts
---| ...
---| ethTypes.ts
---| index.ts

```

This standard layout would lead to an `App.tsx` which renders something like:

```
<Header />
<TabNav
    mainPane={<TxMainPane />}
    sidePane={<TxSidePane />} />
```

**Comments:**
- The `TxModal.tsx` component is included so that each contract function can be imported independently of the rest of the app.  The app would load functions into the MainPane, whereas directly importing one function from the app would load it into a Modal for arbitrary use by the consumer.
- The top-level `types` directory contains types which are shared between Redux files and React components, such as function arguments and primitive Ethereum types.
- `Guardian` service will handle the actual API calls for authentication and transaction submission, it will use a reusable "get current data" selector to fetch the current data payload of the currently-selected function.
- May end up wanting other services or a utils folder -- will see as development progresses.

### Redux Implementation
- separate State Management files from UI files
- follow re-ducks pl0x: https://medium.freecodecamp.org/scaling-your-redux-app-with-ducks-6115955638be
- Create a general "function reducer" 
    - CRUD on a set of fields
    - Maintains the .encodeABI() value
    - Resets on submit action
    - Reads also maintain a result
    - Writes also maintain a value
        -  allowing some application state to be shared by unrelated components makes sense in this case, for maintaining state within a component let's use hooks though (ie. updating when transactions complete/events fire).
- Create "string", "(u)intN", "boolean", "address" reducers to compose for different field types
        - (?) reduce to hex 
- Maintain one instance of the function reducer for each function:
    - Interact with them independently and have state preserved.
    - Generate a case for each one, so it's easy to tweak one afterwards.
    - does the reducer make the final call to the blockchain?
- Maintain a "focused" pointer which goes to an enum of all the function names, lets the UI know what to put in the main view
    - preffer modal approach keep it simple
- Maintain search field for filtering
    - lgtm
- (?) Maintain an array of receipts from past transactions in this session
    - attaching hooks to web3 event listener would be the general way to go

Do not need to store any authentication or address data in Redux, as its part of the DApp is only responsible for building the data payload.  The to will always be fixed to the contract, the from is inferred from Guardian.
## Open Questions
- Do we want the DApp to let you view the status of your transactions once they're made?
    - yes, ideally also any events that get triggered
- Do we want to write in support for non-Guardian authentication?  Could always just hook up Metamask.  Extra work, but also makes these DApps basically in-line with what people are already using.  Also lets people use their existing accounts.
    - skip for now whole point is to get them to stop using it.
