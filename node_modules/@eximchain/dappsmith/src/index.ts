#! /usr/bin/env node

import { AbiDefinition } from "ethereum-types";
import { generate, DappSmithInput } from './DappSmith';
let fs = require("fs");
let path = require("path");
const program = require('commander');
const shell = require('shelljs');
const npmPackage = JSON.parse(fs.readFileSync(path.resolve(__dirname, './../package.json')));

const CALLING_DIR = process.cwd();

program
    .name('dappsmith')
    .version(npmPackage.version)
    .description(npmPackage.description)
    .option('-s, --start', 'Start the Dapp once it has been generated.  Happens after build if both options are specified.')
    .option('-b, --build', 'Build the Dapp once it has been generated.  Happens before start if both options are specified.')
    .usage('<contract_name> <contract_path> <contract_addr> <web3URL> [options]')
    .action((contract_name:string, contract_path:string, contract_addr:string, web3URL: string, options:any={}) => {
        if (process.cwd() !== CALLING_DIR){
            shell.cd(CALLING_DIR);
        }
        if ([contract_name, contract_path, contract_addr, web3URL].some((variable)=>typeof variable !== 'string')){
            console.log("  Dappsmith must be called with (1) a low-cased contract name, (2) a path to its ABI JSON, (3) the contract's deployed address, and (4) an HTTPProvider URL.  Please make sure you've provided all of these values.");
            return false;
        }
        const abi = JSON.parse(
            fs.readFileSync(contract_path)
        ).filter((fxn:AbiDefinition) => fxn.type === 'function');
        const input:DappSmithInput = {abi, name:contract_name, contract_addr, web3URL};

        generate(input, {
            build : options.build,
            start : options.start
        });
    })

program.on('--help', () => {
    console.log('');
    console.log('  Call with the name of your contract (lo-case) and a path to its ABI.  Will generate the DApp in a folder named `[contract-name]-dapp`.');
    console.log('');
})

if (require.main === module){
    const args = process.argv.slice(2)
    if (args.length == 0){
        program.help();
    } else {
        program.parse(process.argv);
    }
}

export default { generate }