import { createContext, useContext, useState, useRef, useEffect } from 'react';

// Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved
// From https://github.com/reduxjs/react-redux/blob/3e53ff96ed10f71c21346f08823e503df724db35/src/utils/shallowEqual.js
var hasOwn = Object.prototype.hasOwnProperty;
function is(x, y) {
    if (x === y) {
        return x !== 0 || y !== 0 || 1 / x === 1 / y;
    }
    else {
        return x !== x && y !== y;
    }
}
function shallowEqual(objA, objB) {
    if (is(objA, objB)) {
        return true;
    }
    if (typeof objA !== 'object' ||
        objA === null ||
        typeof objB !== 'object' ||
        objB === null) {
        return false;
    }
    var keysA = Object.keys(objA);
    var keysB = Object.keys(objB);
    if (keysA.length !== keysB.length) {
        return false;
    }
    // tslint:disable-next-line:prefer-for-of
    for (var i = 0; i < keysA.length; i++) {
        if (!hasOwn.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
            return false;
        }
    }
    return true;
}

// Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved
var CONTEXT_ERROR_MESSAGE = 'redux-react-hook requires your Redux store to ' +
    'be passed through context via the <StoreContext.Provider>';
/**
 * To use redux-react-hook with stronger type safety, or to use with multiple
 * stores in the same app, create() your own instance and re-export the returned
 * functions.
 */
function create() {
    var StoreContext = createContext(null);
    /**
     * Your passed in mapState function should be memoized with useCallback to avoid
     * resubscribing every render. If you don't use other props in mapState, pass
     * an empty array [] as the dependency list so the callback isn't recreated
     * every render.
     *
     * const todo = useMappedState(useCallback(
     *   state => state.todos.get(id),
     *   [id],
     * ));
     */
    function useMappedState(mapState) {
        var store = useContext(StoreContext);
        if (!store) {
            throw new Error(CONTEXT_ERROR_MESSAGE);
        }
        var runMapState = function () { return mapState(store.getState()); };
        var _a = useState(runMapState), derivedState = _a[0], setDerivedState = _a[1];
        var lastStore = useRef(store);
        var lastMapState = useRef(mapState);
        // Keep lastDerivedState in a ref and update it imperatively
        // after calling setDerivedState so it's always up-to-date.
        // We can't update it in useEffect because state might be updated
        // synchronously multiple times before render occurs.
        var lastDerivedState = useRef(derivedState);
        var wrappedSetDerivedState = function () {
            var newDerivedState = runMapState();
            if (!shallowEqual(newDerivedState, lastDerivedState.current)) {
                setDerivedState(newDerivedState);
                lastDerivedState.current = newDerivedState;
            }
        };
        // If the store or mapState change, rerun mapState
        if (lastStore.current !== store || lastMapState.current !== mapState) {
            lastStore.current = store;
            lastMapState.current = mapState;
            wrappedSetDerivedState();
        }
        useEffect(function () {
            var didUnsubscribe = false;
            // Run the mapState callback and if the result has changed, make the
            // component re-render with the new state.
            var checkForUpdates = function () {
                if (didUnsubscribe) {
                    // Don't run stale listeners.
                    // Redux doesn't guarantee unsubscriptions happen until next dispatch.
                    return;
                }
                wrappedSetDerivedState();
            };
            // Pull data from the store after first render in case the store has
            // changed since we began.
            checkForUpdates();
            // Subscribe to the store to be notified of subsequent changes.
            var unsubscribe = store.subscribe(checkForUpdates);
            // The return value of useEffect will be called when unmounting, so
            // we use it to unsubscribe from the store.
            return function () {
                didUnsubscribe = true;
                unsubscribe();
            };
        }, [store, mapState]);
        return derivedState;
    }
    function useDispatch() {
        var store = useContext(StoreContext);
        if (!store) {
            throw new Error(CONTEXT_ERROR_MESSAGE);
        }
        return store.dispatch;
    }
    return {
        StoreContext: StoreContext,
        useDispatch: useDispatch,
        useMappedState: useMappedState,
    };
}

// Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved
var _a;
var StoreContext = (_a = create(), _a.StoreContext), useDispatch = _a.useDispatch, useMappedState = _a.useMappedState;

export { StoreContext, useDispatch, useMappedState, create };
//# sourceMappingURL=index.es.js.map
